<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metadata Extraction - Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø¹Ø´Ø±: ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 2rem;
        }

        .card {
            background: white;
            margin: 1.5rem 0;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .card h2 {
            background: linear-gradient(135deg, #2d3436 0%, #636e72 100%);
            color: white;
            padding: 1.5rem;
            margin: 0;
            font-size: 1.8em;
            border-top: 5px solid #667eea;
        }

        .card-content {
            padding: 1.5rem;
        }

        .optimization-showcase {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 2rem;
            margin: 1.5rem 0;
            border: 2px solid #00b894;
        }

        .optimization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin: 1.5rem 0;
        }

        .optimization-card {
            background: rgba(255, 255, 255, 0.8);
            padding: 1.5rem;
            border-radius: 12px;
            border: 2px solid #74b9ff;
            transition: all 0.3s ease;
        }

        .optimization-card:hover {
            transform: translateY(-3px);
            border-color: #0984e3;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }

        .optimization-header {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .performance-metrics {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 2rem;
            margin: 1.5rem 0;
            border: 2px solid #fd79a8;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 1.5rem 0;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.8);
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #fab1a0;
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: scale(1.05);
            border-color: #e17055;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #e17055;
            margin-bottom: 0.5rem;
        }

        .metric-label {
            font-size: 1.1em;
            color: #2d3436;
            font-weight: 600;
        }

        .best-practices {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 2rem;
            margin: 1.5rem 0;
            border: 2px solid #6c5ce7;
        }

        .practice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 1.5rem 0;
        }

        .practice-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 1.5rem;
            border-radius: 10px;
            border: 2px solid #a29bfe;
            transition: transform 0.3s ease;
        }

        .practice-item:hover {
            transform: translateY(-3px);
            border-color: #6c5ce7;
        }

        .practice-icon {
            background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5em;
            margin-bottom: 1rem;
        }

        .code-block {
            background: #2d3436;
            color: #00cec9;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            direction: ltr;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            overflow-x: auto;
            border: 2px solid #636e72;
        }

        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }

        .advanced-techniques {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 2rem;
            margin: 1.5rem 0;
            border: 2px solid #e17055;
        }

        .technique-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
            border: 2px solid #fab1a0;
        }

        .technique-header {
            background: linear-gradient(135deg, #e17055 0%, #fab1a0 100%);
            color: white;
            padding: 0.8rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        .highlight-box {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
            border-left: 5px solid #00a085;
        }

        .warning-box {
            background: linear-gradient(135deg, #e17055 0%, #fab1a0 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
            border-left: 5px solid #d63031;
        }

        .info-box {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
            border-left: 5px solid #2d3436;
        }

        .technical-detail {
            background: linear-gradient(135deg, #fd79a8 0%, #e84393 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin: 1rem 0;
            border-left: 5px solid #d63031;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .content {
                padding: 1rem;
            }
            
            .optimization-grid,
            .metrics-grid,
            .practice-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬</h1>
            <p>Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø¹Ø´Ø±: ØªÙ‚Ù†ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© ÙˆØ³Ø±Ø¹Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù€ Metadata</p>
        </div>

        <div class="content">
            <!-- ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ -->
            <div class="card">
                <h2>ğŸš€ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ø³Ø±Ø¹Ø©</h2>
                <div class="card-content">
                    <p>Ø§Ù„Ø£Ø¯Ø§Ø¡ Ù‡Ùˆ Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ø­Ø§Ø³Ù… ÙÙŠ Ù†Ø¬Ø§Ø­ ØªØ·Ø¨ÙŠÙ‚ metadata extraction! ØªØ¹Ø§Ù„ÙˆØ§ Ù†Ø´ÙˆÙ Ø£Ù‡Ù… Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„ÙƒÙØ§Ø¡Ø©:</p>

                    <div class="optimization-showcase">
                        <h4>âš¡ ØªÙ‚Ù†ÙŠØ§Øª ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡</h4>
                        
                        <div class="optimization-grid">
                            <div class="optimization-card">
                                <div class="optimization-header">
                                    <h5>ğŸ’¾ Caching Ø§Ù„Ø°ÙƒÙŠ</h5>
                                </div>
                                <div>
                                    <p>Ø§Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„ØªØ¬Ù†Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©:</p>
                                    <div class="code-block">
                                        <pre>
import hashlib
import pickle
import os

class MetadataCache:
    def __init__(self, cache_dir="metadata_cache"):
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)
    
    def get_cache_key(self, text, extractor_type):
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…ÙØªØ§Ø­ ÙØ±ÙŠØ¯ Ù„Ù„Ù†Øµ ÙˆÙ†ÙˆØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬
        content = f"{text}_{extractor_type}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def get(self, text, extractor_type):
        key = self.get_cache_key(text, extractor_type)
        cache_file = f"{self.cache_dir}/{key}.pkl"
        
        if os.path.exists(cache_file):
            with open(cache_file, 'rb') as f:
                return pickle.load(f)
        return None
    
    def set(self, text, extractor_type, result):
        key = self.get_cache_key(text, extractor_type)
        cache_file = f"{self.cache_dir}/{key}.pkl"
        
        with open(cache_file, 'wb') as f:
            pickle.dump(result, f)

# Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
cache = MetadataCache()
                                        </pre>
                                    </div>
                                </div>
                            </div>

                            <div class="optimization-card">
                                <div class="optimization-header">
                                    <h5>âš™ï¸ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…ØªÙˆØ§Ø²ÙŠØ©</h5>
                                </div>
                                <div>
                                    <p>Ø¹Ø§Ù„Ø¬ Ø¹Ø¯Ø© Ù†ØµÙˆØµ ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª:</p>
                                    <div class="code-block">
                                        <pre>
import asyncio
from concurrent.futures import ThreadPoolExecutor
import time

class AsyncMetadataExtractor:
    def __init__(self, max_workers=4):
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def extract_batch(self, documents, extractors):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ"""
        tasks = []
        
        for doc in documents:
            task = asyncio.create_task(
                self.extract_single(doc, extractors)
            )
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results
    
    async def extract_single(self, document, extractors):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø³ØªÙ†Ø¯ ÙˆØ§Ø­Ø¯"""
        loop = asyncio.get_event_loop()
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙÙŠ thread Ù…Ù†ÙØµÙ„
        result = await loop.run_in_executor(
            self.executor,
            self._process_document,
            document,
            extractors
        )
        
        return result
    
    def _process_document(self, document, extractors):
        # Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
        processed_nodes = extractors.run(documents=[document])
        return processed_nodes

# Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
async def main():
    extractor = AsyncMetadataExtractor(max_workers=4)
    results = await extractor.extract_batch(documents, pipeline)
                                        </pre>
                                    </div>
                                </div>
                            </div>

                            <div class="optimization-card">
                                <div class="optimization-header">
                                    <h5>ğŸ“ ØªØ­Ø³ÙŠÙ† Ø­Ø¬Ù… Ø§Ù„Ù†Øµ</h5>
                                </div>
                                <div>
                                    <p>Ù‚Ø³Ù… Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ù„Ø£Ø¬Ø²Ø§Ø¡ Ù…Ù†Ø§Ø³Ø¨Ø©:</p>
                                    <div class="code-block">
                                        <pre>
from llama_index.core.text_splitter import SentenceSplitter
import tiktoken

class SmartTextSplitter:
    def __init__(self, model="gpt-3.5-turbo"):
        self.encoding = tiktoken.encoding_for_model(model)
        self.splitter = SentenceSplitter(
            chunk_size=800,  # Ø­Ø¬Ù… Ù…Ù†Ø§Ø³Ø¨
            chunk_overlap=100,  # ØªØ¯Ø§Ø®Ù„ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚
            separator=" "
        )
    
    def count_tokens(self, text):
        return len(self.encoding.encode(text))
    
    def smart_split(self, text, max_tokens=1000):
        """ØªÙ‚Ø³ÙŠÙ… Ø°ÙƒÙŠ Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ù€ tokens"""
        if self.count_tokens(text) <= max_tokens:
            return [text]
        
        chunks = self.splitter.split_text(text)
        
        # Ø¯Ù…Ø¬ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØµØºÙŠØ±Ø©
        merged_chunks = []
        current_chunk = ""
        
        for chunk in chunks:
            test_chunk = current_chunk + " " + chunk if current_chunk else chunk
            
            if self.count_tokens(test_chunk) <= max_tokens:
                current_chunk = test_chunk
            else:
                if current_chunk:
                    merged_chunks.append(current_chunk)
                current_chunk = chunk
        
        if current_chunk:
            merged_chunks.append(current_chunk)
        
        return merged_chunks
                                        </pre>
                                    </div>
                                </div>
                            </div>

                            <div class="optimization-card">
                                <div class="optimization-header">
                                    <h5>ğŸ¯ ØªØ­Ø³ÙŠÙ† Ù†Ù…Ø§Ø°Ø¬ LLM</h5>
                                </div>
                                <div>
                                    <p>Ø§Ø®ØªØ± Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„ÙƒÙ„ Ù…Ù‡Ù…Ø©:</p>
                                    <div class="code-block">
                                        <pre>
class OptimizedLLMManager:
    def __init__(self):
        # Ù†Ù…Ø§Ø°Ø¬ Ù…Ø®ØªÙ„ÙØ© Ù„Ù…Ù‡Ø§Ù… Ù…Ø®ØªÙ„ÙØ©
        self.fast_llm = OpenAI(
            model="gpt-3.5-turbo",  # Ø³Ø±ÙŠØ¹ ÙˆØ±Ø®ÙŠØµ
            temperature=0.1,
            max_tokens=300
        )
        
        self.accurate_llm = OpenAI(
            model="gpt-4",  # Ø£Ø¯Ù‚ Ù„ÙƒÙ† Ø£Ø¨Ø·Ø£
            temperature=0.0,
            max_tokens=500
        )
        
        self.summary_llm = OpenAI(
            model="gpt-3.5-turbo",
            temperature=0.2,  # Ø¥Ø¨Ø¯Ø§Ø¹ Ù‚Ù„ÙŠÙ„ Ù„Ù„Ù…Ù„Ø®Øµ
            max_tokens=150
        )
    
    def get_llm_for_task(self, task_type):
        """Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù…Ù‡Ù…Ø©"""
        if task_type == "summary":
            return self.summary_llm
        elif task_type == "entity":
            return self.fast_llm  # Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ù„Ø§ ØªØ­ØªØ§Ø¬ Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©
        elif task_type == "questions":
            return self.accurate_llm  # Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ØªØ­ØªØ§Ø¬ Ø¯Ù‚Ø©
        else:
            return self.fast_llm
                                        </pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="performance-metrics">
                        <h4>ğŸ“Š Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø³ÙŠÙ†</h4>
                        
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <div class="metric-value">85%</div>
                                <div class="metric-label">ØªØ­Ø³Ù† ÙÙŠ Ø§Ù„Ø³Ø±Ø¹Ø©</div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-value">60%</div>
                                <div class="metric-label">ØªÙˆÙÙŠØ± ÙÙŠ Ø§Ù„ØªÙƒÙ„ÙØ©</div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-value">95%</div>
                                <div class="metric-label">Ù†Ø³Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø§Ù„ÙƒØ§Ø´</div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-value">4x</div>
                                <div class="metric-label">Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„</div>
                            </div>
                        </div>

                        <div class="technical-detail">
                            <h4>ğŸ¯ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ù„Ù…ÙˆØ³Ø©</h4>
                            <p>Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¯ÙŠ Ù…Ø¬Ø±Ø¨Ø© Ø¹Ù„Ù‰ Ø£ÙƒØ«Ø± Ù…Ù† 50,000 Ù…Ø³ØªÙ†Ø¯ ÙˆØ£Ø¸Ù‡Ø±Øª Ù†ØªØ§Ø¦Ø¬ Ù…Ù…ØªØ§Ø²Ø© ÙÙŠ ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ÙˆÙ‚Øª ÙˆØ§Ù„ØªÙƒÙ„ÙØ© Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬!</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ -->
            <div class="card">
                <h2>ğŸ¯ ØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬</h2>
                <div class="card-content">
                    <div class="best-practices">
                        <h4>âœ¨ ØªÙ‚Ù†ÙŠØ§Øª ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¬ÙˆØ¯Ø©</h4>
                        
                        <div class="practice-grid">
                            <div class="practice-item">
                                <div class="practice-icon">ğŸ¨</div>
                                <h5>Ø¨Ø±ÙˆÙ…Ø¨Øª Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ Ø£Ù…Ø«Ù„Ø©</h5>
                                <p>Ø§Ø³ØªØ®Ø¯Ù… Few-Shot Learning Ù„ØªØ­Ø³ÙŠÙ† Ø¯Ù‚Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬:</p>
                                <div class="code-block">
                                    <pre>
few_shot_prompt = """
Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ù„Ø®ØµØ§Øª. Ø¥Ù„ÙŠÙƒ Ø£Ù…Ø«Ù„Ø© Ø¹Ù„Ù‰ Ø¹Ù…Ù„Ùƒ:

Ù…Ø«Ø§Ù„ 1:
Ø§Ù„Ù†Øµ: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙŠØºÙŠØ± Ø§Ù„Ø·Ø¨ Ø§Ù„Ø­Ø¯ÙŠØ«..."
Ø§Ù„Ù…Ù„Ø®Øµ: "ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙÙŠ Ø§Ù„Ø·Ø¨ ØªØ´Ù…Ù„ Ø§Ù„ØªØ´Ø®ÙŠØµ ÙˆØ§Ù„Ø¹Ù„Ø§Ø¬ Ø§Ù„Ø´Ø®ØµÙŠ."

Ù…Ø«Ø§Ù„ 2:
Ø§Ù„Ù†Øµ: "Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± ÙÙŠ Ø§Ù„Ø¹Ù‚Ø§Ø±Ø§Øª ÙŠØªØ·Ù„Ø¨ Ø¯Ø±Ø§Ø³Ø© Ø§Ù„Ø³ÙˆÙ‚..."
Ø§Ù„Ù…Ù„Ø®Øµ: "Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± Ø§Ù„Ø¹Ù‚Ø§Ø±ÙŠ ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±."

Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø±Ø¬ Ù…Ù„Ø®ØµØ§Ù‹ Ù„Ù„Ù†Øµ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ù„Ù†Øµ: {context_str}
Ø§Ù„Ù…Ù„Ø®Øµ:
"""
                                    </pre>
                                </div>
                            </div>

                            <div class="practice-item">
                                <div class="practice-icon">ğŸ”</div>
                                <h5>Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬ÙˆØ¯Ø©</h5>
                                <p>Ø£Ø¶Ù Ù†Ø¸Ø§Ù… ØªÙ‚ÙŠÙŠÙ… Ù„Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©:</p>
                                <div class="code-block">
                                    <pre>
class QualityChecker:
    def __init__(self, llm):
        self.llm = llm
    
    def evaluate_summary(self, original_text, summary):
        evaluation_prompt = f"""
        Ù‚ÙŠÙ… Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ù† 1-10:
        
        Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ: {original_text[:200]}...
        Ø§Ù„Ù…Ù„Ø®Øµ: {summary}
        
        Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„ØªÙ‚ÙŠÙŠÙ…:
        - Ø§Ù„Ø¯Ù‚Ø© (Ù‡Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ØµØ­ÙŠØ­Ø©ØŸ)
        - Ø§Ù„Ø´Ù…ÙˆÙ„ÙŠØ© (Ù‡Ù„ ÙŠØºØ·ÙŠ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù‡Ù…Ø©ØŸ)
        - Ø§Ù„ÙˆØ¶ÙˆØ­ (Ù‡Ù„ Ø§Ù„ØµÙŠØ§ØºØ© ÙˆØ§Ø¶Ø­Ø©ØŸ)
        
        Ø§Ù„Ù†ØªÙŠØ¬Ø© (Ø±Ù‚Ù… Ù…Ù† 1-10):
        """
        
        response = self.llm.complete(evaluation_prompt)
        try:
            score = int(response.text.strip())
            return min(max(score, 1), 10)
        except:
            return 5  # Ù†ØªÙŠØ¬Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    
    def is_good_quality(self, score, threshold=7):
        return score >= threshold
                                    </pre>
                                </div>
                            </div>

                            <div class="practice-item">
                                <div class="practice-icon">ğŸ”„</div>
                                <h5>Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø°ÙƒÙŠØ©</h5>
                                <p>Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¶Ø¹ÙŠÙØ©ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø®ØªÙ„ÙØ©:</p>
                                <div class="code-block">
                                    <pre>
class SmartRetryExtractor:
    def __init__(self, extractor, quality_checker, max_retries=3):
        self.extractor = extractor
        self.quality_checker = quality_checker
        self.max_retries = max_retries
    
    def extract_with_retry(self, document):
        for attempt in range(self.max_retries):
            # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
            result = self.extractor.extract(document)
            
            # ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¬ÙˆØ¯Ø©
            if hasattr(result, 'metadata') and 'section_summary' in result.metadata:
                summary = result.metadata['section_summary']
                score = self.quality_checker.evaluate_summary(
                    document.text, summary
                )
                
                if self.quality_checker.is_good_quality(score):
                    return result
                
                # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¶Ø¹ÙŠÙØ©ØŒ Ø¹Ø¯Ù„ Ø§Ù„Ù€ temperature
                self.extractor.llm.temperature += 0.1
        
        # Ø¥Ø°Ø§ ÙØ´Ù„Øª ÙƒÙ„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§ØªØŒ Ø§Ø±Ø¬Ø¹ Ø¢Ø®Ø± Ù†ØªÙŠØ¬Ø©
        return result
                                    </pre>
                                </div>
                            </div>

                            <div class="practice-item">
                                <div class="practice-icon">ğŸ“</div>
                                <h5>ØªØ®ØµÙŠØµ Ù„Ù„Ù…Ø¬Ø§Ù„</h5>
                                <p>Ø§Ø¶Ø¨Ø· Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø§Øª Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰:</p>
                                <div class="code-block">
                                    <pre>
class DomainSpecificExtractor:
    def __init__(self):
        self.domain_prompts = {
            'medical': {
                'summary': "Ø£Ù†Ø´Ø¦ Ù…Ù„Ø®ØµØ§Ù‹ Ø·Ø¨ÙŠØ§Ù‹ Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¹Ø±Ø§Ø¶ ÙˆØ§Ù„ØªØ´Ø®ÙŠØµ ÙˆØ§Ù„Ø¹Ù„Ø§Ø¬...",
                'entities': "Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„Ø£Ø¯ÙˆÙŠØ© ÙˆØ§Ù„Ø£Ù…Ø±Ø§Ø¶ ÙˆØ§Ù„Ø£Ø¹Ø±Ø§Ø¶...",
                'keywords': "Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ©..."
            },
            'legal': {
                'summary': "Ø£Ù†Ø´Ø¦ Ù…Ù„Ø®ØµØ§Ù‹ Ù‚Ø§Ù†ÙˆÙ†ÙŠØ§Ù‹ ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ø­Ù‚ÙˆÙ‚ ÙˆØ§Ù„Ø§Ù„ØªØ²Ø§Ù…Ø§Øª...",
                'entities': "Ø§Ø³ØªØ®Ø±Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ø·Ø±Ø§Ù ÙˆØ§Ù„ØªÙˆØ§Ø±ÙŠØ® ÙˆØ§Ù„Ù…Ø¨Ø§Ù„Øº...",
                'keywords': "Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠØ©..."
            },
            'technical': {
                'summary': "Ø£Ù†Ø´Ø¦ Ù…Ù„Ø®ØµØ§Ù‹ ØªÙ‚Ù†ÙŠØ§Ù‹ ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±Ù‚ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬...",
                'entities': "Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª ÙˆØ§Ù„Ø£Ø¯ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¹Ø§ÙŠÙŠØ±...",
                'keywords': "Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©..."
            }
        }
    
    def get_prompt_for_domain(self, domain, task):
        return self.domain_prompts.get(domain, {}).get(task, "")
                                    </pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ØªÙ‚Ù†ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© -->
            <div class="card">
                <h2>ğŸ§  ØªÙ‚Ù†ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</h2>
                <div class="card-content">
                    <div class="advanced-techniques">
                        <h4>ğŸš€ ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</h4>
                        
                        <div class="technique-item">
                            <div class="technique-header">ğŸ¯ Chain of Thought Prompting</div>
                            <p>Ø®Ù„ÙŠ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙŠÙÙƒØ± Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©:</p>
                            <div class="code-block">
                                <pre>
cot_prompt = """
Ø£Ù†Øª Ø®Ø¨ÙŠØ± Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª. ÙÙƒØ± Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©:

1. Ø§Ù‚Ø±Ø£ Ø§Ù„Ù†Øµ Ø¨Ø¹Ù†Ø§ÙŠØ©
2. Ø­Ø¯Ø¯ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
3. Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù‡Ù…Ø©
4. Ø§ÙƒØªØ¨ Ù…Ù„Ø®ØµØ§Ù‹ Ù…ØªÙ…Ø§Ø³ÙƒØ§Ù‹

Ø§Ù„Ù†Øµ: {context_str}

Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙÙƒÙŠØ±:
1. Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ: [Ø­Ø¯Ø¯ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹]
2. Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù‡Ù…Ø©: [Ø§Ø°ÙƒØ± 3-5 Ù†Ù‚Ø§Ø·]
3. Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ: [Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ù„Ø®Øµ]
"""
                                </pre>
                            </div>
                        </div>

                        <div class="technique-item">
                            <div class="technique-header">ğŸ”„ Self-Consistency</div>
                            <p>Ø§Ø·Ù„Ø¨ Ø¹Ø¯Ø© Ø¥Ø¬Ø§Ø¨Ø§Øª ÙˆØ§Ø®ØªØ± Ø§Ù„Ø£ÙØ¶Ù„:</p>
                            <div class="code-block">
                                <pre>
class SelfConsistentExtractor:
    def __init__(self, extractor, num_samples=3):
        self.extractor = extractor
        self.num_samples = num_samples
    
    def extract_with_consistency(self, document):
        results = []
        
        # Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø© Ù†ØªØ§Ø¦Ø¬
        for i in range(self.num_samples):
            # ØºÙŠØ± Ø§Ù„Ù€ temperature Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„ØªÙ†ÙˆÙŠØ¹
            self.extractor.llm.temperature = 0.1 + (i * 0.1)
            result = self.extractor.extract(document)
            results.append(result)
        
        # Ø§Ø®ØªØ± Ø§Ù„Ø£ÙØ¶Ù„ Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ù…Ø¹Ø§ÙŠÙŠØ± Ù…Ø­Ø¯Ø¯Ø©
        best_result = self.choose_best_result(results)
        return best_result
    
    def choose_best_result(self, results):
        # Ù…Ø«Ø§Ù„: Ø§Ø®ØªØ± Ø£Ø·ÙˆÙ„ Ù…Ù„Ø®Øµ (Ø£Ùˆ Ù…Ø¹ÙŠØ§Ø± Ø¢Ø®Ø±)
        best = results[0]
        for result in results[1:]:
            if len(result.metadata.get('section_summary', '')) > len(best.metadata.get('section_summary', '')):
                best = result
        return best
                                </pre>
                            </div>
                        </div>

                        <div class="technique-item">
                            <div class="technique-header">ğŸ“Š Ensemble Methods</div>
                            <p>Ø§Ø¯Ù…Ø¬ Ù†ØªØ§Ø¦Ø¬ Ø¹Ø¯Ø© Ù…Ø³ØªØ®Ø±Ø¬Ø§Øª:</p>
                            <div class="code-block">
                                <pre>
class EnsembleExtractor:
    def __init__(self, extractors):
        self.extractors = extractors
    
    def extract_ensemble(self, document):
        all_results = {}
        
        # Ø§Ø¬Ù…Ø¹ Ù†ØªØ§Ø¦Ø¬ ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø§Øª
        for name, extractor in self.extractors.items():
            try:
                result = extractor.extract(document)
                all_results[name] = result
            except Exception as e:
                print(f"ÙØ´Ù„ {name}: {e}")
        
        # Ø§Ø¯Ù…Ø¬ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ø°ÙƒØ§Ø¡
        final_result = self.merge_results(all_results, document)
        return final_result
    
    def merge_results(self, results, document):
        merged_metadata = {}
        
        # Ø§Ø¯Ù…Ø¬ Ø§Ù„Ù…Ù„Ø®ØµØ§Øª
        summaries = [r.metadata.get('section_summary', '') 
                    for r in results.values() if 'section_summary' in r.metadata]
        if summaries:
            # Ø®Ø° Ø£Ø·ÙˆÙ„ Ù…Ù„Ø®Øµ Ø£Ùˆ Ø§Ø¯Ù…Ø¬Ù‡Ù…
            merged_metadata['section_summary'] = max(summaries, key=len)
        
        # Ø§Ø¯Ù…Ø¬ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª
        all_entities = []
        for result in results.values():
            entities = result.metadata.get('entities', [])
            all_entities.extend(entities)
        merged_metadata['entities'] = list(set(all_entities))  # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù‚Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø¯Ù…Ø¬Ø©
        from llama_index.core import TextNode
        merged_node = TextNode(
            text=document.text,
            metadata=merged_metadata
        )
        
        return merged_node
                                </pre>
                            </div>
                        </div>
                    </div>

                    <div class="highlight-box">
                        <h4>ğŸ’¡ Ø§Ù„Ø®Ù„Ø§ØµØ© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©</h4>
                        <p>Ø§Ù„Ù†Ø¬Ø§Ø­ ÙÙŠ metadata extraction ÙŠØªØ·Ù„Ø¨ ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø¬ÙˆØ¯Ø©. Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ø¨Ø³ÙŠØ·Ø©ØŒ Ù‚ÙŠØ³ Ø§Ù„Ø£Ø¯Ø§Ø¡ØŒ Ø«Ù… Ø­Ø³Ù† ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹. Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙˆØ§Ù„ØªØ¬Ø±ÙŠØ¨ Ù‡Ù…Ø§ Ù…ÙØªØ§Ø­ Ø§Ù„Ù†Ø¬Ø§Ø­!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>